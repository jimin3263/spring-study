## 서블릿 예외 처리

### Exception
- `throw new RuntimeException("예외 발생");`
- 웹 애플리케이션은 사용자 요청별로 별도의 쓰레드가 할당되고, 서블릿 컨테이너 안에서 실행됨  
- 이때 애플리케이션에서 예외를 잡지 못하고 서블릿 밖으로 예외가 전달된다면? *-> 톰캣이 기본으로 오류 화면 제공해줌*

### response.sendError()
- `response.sendError(HTTP 상태 코드)`
- `response.sendError(HTTP 상태 코드, 오류 메시지)` 통해 오류 발생 전달 해줌
- `response` 내부에는 오류가 발생했다는 상태 저장해두고 서블릿 컨테이너는 고객에게 응답 전에 `sendError()`가 호출되었는지 확인함
```
WAS(sendError 호출 기록 확인) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러
```

## 오류 화면 제공

> WebServerCustomizer
```java
@Component
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
    @Override
    public void customize(ConfigurableWebServerFactory factory) {

        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");
        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");

        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);

    }
}

```
- 서블릿 오류 페이지를 등록해줌
- `ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404")`: 오류가 발생하면 등록해준 서블릿 오류 페이지 URL로 보내줌
- **요청 흐름**
```
1. WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
2. WAS `/error-page/500` 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러(/error-page/500) -> View
```

## 필터
: 오류 발생하면 WAS 내부에서 다시 호출이 일어나는데, 필터, 서블릿, 인터셉터도 모두 다시 호출된다.  
따라서 클라이언트로부터 발생한 정상 요청인지 오류 페이지를 출력하기 위한 내부 요청인지 구분이 필요함 -> `Dispatchertype`  

#### Dispatchertype
- `log.info("dispatchType={}", request.getDispatcherType())`의 결과
  - REQUEST : 클라이언트 요청
  - ERROR : 내부 오류 요청
  - FORWARD : MVC에서 배웠던 서블릿에서 다른 서블릿이나 JSP를 호출할 때 `RequestDispatcher.forward(request, response);`
  - INCLUDE : 서블릿에서 다른 서블릿이나 JSP의 결과를 포함할 때`RequestDispatcher.include(request, response);`
  - ASYNC : 서블릿 비동기 호출
- 필터 등록시 `filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);`
  - 클라이언트 요청, 내부 오류 모두 필터 호출됨
  - 아무것도 넣지 않으면 기본 값은 `DispatcherType.REQUEST`
  - 따라서 ERROR를 지정하지 않는 이상 큰 문제는 되지 않을 것

## 인터셉터

- 필터와 다르게 DispatcherType은 지원하지 않지만 excludePathPatterns을 사용해서 경로를 제한해줌
- `excludePathPatterns("/css/**", "*.ico", "/error", "/error-page/**");`

## 스프링 부트 - 오류 페이지

- ErrorPage를 `/error`라는 경로로 기본 오류 페이지 설정해줌  
- `BasicErrorcontroller`라는 컨트롤러를 자동으로 등록함  

*->이제 오류가 발생했을 때 오류 페이지로 /error 를 기본 요청한다. 스프링 부트가 자동 등록한 BasicErrorController 는 이 경로를 기본으로 받는다.*  

- **뷰 선택 우선 순위**
  - 뷰 템플릿
  - 정적 리소스
  - 적용 대상이 없을 때 뷰 이름 (error.html)
  - 또한 4xx.html보다 구체적인 404.html이 우선순위를 가짐

- 오류 정보 조회

> /error/500.html  
```html
    <ul>
        <li>오류 정보</li>
        <ul>
            <li th:text="|timestamp: ${timestamp}|"></li>
            <li th:text="|path: ${path}|"></li>
            <li th:text="|status: ${status}|"></li>
            <li th:text="|message: ${message}|"></li>
            <li th:text="|error: ${error}|"></li>
            <li th:text="|exception: ${exception}|"></li>
            <li th:text="|errors: ${errors}|"></li>
            <li th:text="|trace: ${trace}|"></li>
        </ul>
        </li>
    </ul>
```
> application.properties

```
server.error.include-exception=true
server.error.include-message=on_param
server.error.include-stacktrace=on_param
server.error.include-binding-errors=on_param
```
- 에러에 대한 상세 정보를 설정해서 추가할 수는 있지만 노출해서는 안됨
- 옵션
  - `never` : 사용하지 않음
  - `always` :항상 사용
  - `on_param` : 파라미터가 있을 때 사용
- 또 다른 설정
  - `server.error.whitelabel.enabled=true`: 오류 처리 화면을 못 찾을 시, 스프링 whitelabel 오류 페이지 적용
  - `server.error.path=/error`: 기본 값이니까 건드리지는 않음





