# HTTP 기본

## 모든 것이 HTTP
- HTML, TEXT
- JSON, XML
- 서버간에 데이터를 주고 받을 때
- 이미지, 음성, 영상, 파일

*-> HTTP/1.1 주로 사용, HTTP/2, HTTP/2도 점점 증가*

### HTTP 특징
- 클라이언트, 서버 구조
- 무상태 프로토콜(stateless), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

## 클라이언트 서버 구조
- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답
- 비지니스 로직을 분리함으로써 클라이언트, 서버가 독립적으로 발전 가능

## Stateless/Stateful

### Stateless
- 서버가 클라이언트 상태를 보존하지 않음
- stateless는 응답 서버를 쉽게 바꿀 수 있음 -> 무한한 서버 증설 가능
- 클라이언트가 필요한 데이터를 다 담아서 보냄
- **한계**
  - 로그인과 같은 상태 유지 필요  
  *-> 쿠키, 세션 사용* 
  - 데이터 많이 저장해야 함

### Stateful
- 항상 같은 서버가 유지되어야 함
- 중간에 서버가 장애나면 클라이언트는 다시 처음부터

## Connectionless
- 응답 이후, 연결 끊음
- 자원을 요청 주고 받을 때만 연결을 유지해서 최소한의 자원을 유지할 수 있음
- **한계**
  - TCP/IP 연결을 새로 맺어야 함
  - HTML 뿐만 아니라 다른 자원들도 함께 다운
   *-> Persistent Connecions*
   
 ## HTTP 메시지
 
 ![image](https://user-images.githubusercontent.com/50178026/125977900-cd47bdf7-a6ab-4dbe-b125-fe5467fcae9c.png)
 
 ### Start-line
 #### 요청 메시지
 - start-line = **request-line** / status-line
 - request-line: method request-target HTTP-version
  - **method**: GET, POST, PUT, DELETE
  - **request-target**: 절대경로?쿼리

 #### 응답 메시지
 - start-line = request-line / **status-line**
 - status-line: HTTP-version status-code reason-phrase
  - **status code**: 요청 성공, 실패 나타냄
  - **reason-phrase**: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### HTTP header
- field name":" OWS field-value OWS (OWS: 띄어쓰기 허용)
- HTTP 전송에 필요한 모든 부가 정보
  - 메시지 바디 내용(HTML/XML 인가?), 메시지 바디 크기, 압축, 요청 클라이언트 정보 등등

### Message Body
- 실제 전송할 데이터
- byte로 표현할 수 있는 모든 데이터 전송 가능

# HTTP 메서드

### 리소스 식별
- 회원을 등록하고 수정하고 조회하는게 리소스가 아님
  - 회원이라는 **개념 자체**가 리소스
### 리소스와 행위 분리
- URI 리소스만 식별
- 리소스와 해당 리소스를 대상으로 하는 **행위** 분리
  - 리소스: 회원
  - 행위: 조회, 등록, 삭제, 변경
  - **리소스는 명사, 행위는 동사**
  *-> 행위 구별은 HTTP 메서드가 구별*

## HTTP 메서드 종류
- **GET**: 리소스 조회
- **POST**: 요청 데이터 처리, 주로 등록에 사용
- **PUT**: 리소스를 대체, 해당 리소스가 없으면 생성
- **PATCH**: 리소스 부분 변경
- **DELETE**: 리소스 삭제

### GET
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수는 있지만 지원하지 않는 곳이 많아서 권장하지 않음

### POST
- 요청 데이터 처리
- **메시지 바디를 통해 서버로 요청 데이터 전달**
- 서버는 요청 데이터를 처리
  - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
- POST 예시
  - HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공 -> 회원 가입, 주문
  - 게시판, 블로그 등 메시지 게시 -> 게시판 글쓰기, 댓글 달기
  - 서버가 아직 식별하지 않은 새 리소스 생성 -> 신규 주문 생성
  - 기존 자원에 데이터 추가 -> 한 문서 끝에 내용 추가
  - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음 -> POST /orders/{orderId}/start (컨트롤 URI)

### PUT
- 리소스 **완전히** 대체
  - 리소스가 있으면 대체
  - 리소스가 없으면 생성
  - 쉽게 이야기해서 덮어씀
- 클라이언트가 리소스를 식별
  - 클라이언트가 **리소스 위치를 알고 URI 지정**

### PATCH
- 리소스 **부분** 변경

### DELETE
- 리소스 제거

## HTTP 메서드의 속성
### 안전(Safe Methods)
  - 호출해도 리소스를 변경하지 않음
  *-> 변경하지 않는 메소드만 안전 (get, head 등)*
### 멱등(Idempotent Methods)
- f(f(x)) = f(x)
- 여러번 호출해도 결과 같음
- GET, PUT, DELETE
- POST는 멱등 아님 -> 두 번 호출하면 같은 결제가 중복해서 발생할 수 있음
- 자동 복구 메커니즘
  - 같은 요청을 여러 번해도 되니까
- 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않음(GET -> PUT으로 리소스 변경 -> GET)
### 캐시가능(Caheable Methods)
- 리소스를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH 캐시 가능
- GET, HEAD 정도만 캐시 사용 -> URL만 키로 잡고 
  - POST, PATCh는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음





